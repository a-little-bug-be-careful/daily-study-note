# MySQL学习总结

## 一、常用函数

1. 字符串操作函数

   > 1. concat(s1,s2,s3)拼接字符串
   > 2. trim(s1)去除字符串首尾空格
   > 3. lower(str)将字符串转化为小写
   > 4. upper(str)将字符串转化为大写
   > 5. LPAD(str, n, pad)用字符串pad对str进行左填充使其达到n个字符长度
   > 6. RPAD又填充
   > 7. SUBSTR(str, start, end)截取字符串指定长度

2. 日期函数

   > select *curdate*();获取当前日期不包含时分秒
   > select *curtime*();获取当前时间不包含年月日
   > select *now*();获取年月日加时分秒
   > select *year*('2001-02-03');获取指定日期年份信息
   > select *month*('2001-02-03');获取指定日期月份
   > select *day*('2001-02-03');获取指定日期天
   > select *date_add*('2001-02-03', interval 10 day );计算指定日期加上一个时间zhizhi后的日期
   > select *datediff*('2001-02-03', '2001-02-01');计算两个日期之间时间差

3. 数值函数

   > 1. CEIL向上取整
   > 2. FLOOR向下取整
   > 3. MOD(x,y)返回x/y的模
   > 4. RAND返回0-1的随机数
   > 5. ROUND(x,y)求参数x的四舍五入的数，保留y位小数

4. 流程函数

   > select *if*(false, 'a', 'b');如果第一个值为true则返回第二个值，否则返回第三个值
   > select *ifnull*(null, 'a');如果第一个值为null（不是空字符），则返回第二个值，否则返回第一个值
   >
   > case when then else



## 二、约束

1. 外键约束
2. 唯一约束
3. 主键约束

## 三、多表查询

1. 内连接：集合的交集，inner join

2. 外连接：左外连接，右外连接

   > 左外连接：以左表为基础，右表作为补充
   >
   > 右外连接：以右表为基础，左表作为补充

3. 自连接

4. 联合查询：

   > union：去重
   >
   > union all：不去重

5. 子查询

   > - 标量子查询（子查询结果为单个值，一行一列）
   > - 列子查询（子查询结果为一列）
   > - 行子查询（子查询结果为一行数据）
   > - 表子查询（子查询结果为一张表）

## 四、DQL查询语句执行顺序

1. FROM
2. WHERE
3. GROUP BY
4. SELECT
5. ORDER BY
6. LIMIT

## 五、事务

1. 四大特性ACID：

   > - A：原子性
   > - C：一致性
   > - I：隔离性
   > - D：持久性

2. 并发事务问题

   > - 脏读：事务A读取到了事务B未提交的数据
   > - 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现数据存在，像是出现了幻觉
   > - 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同

3. 事务隔离级别

   > - 读取未提交：脏读、幻读、不可重复读不可避免
   > - 读取已提交（Oracle默认隔离级别）：脏读可以避免，幻读和不可重复读不可避免
   > - 可重读（MySQL的默认隔离级别）：脏读、不可重复读可以避免，幻读不可避免
   > - 串行化：都可避免

## 六、存储引擎

存储引擎是和表相关联的，不是和数据库关联的，MySQL不同的表可以使用不同的存储引擎，通过在创建表时指定engine=xxx，如果不指定默认为INNODB存储引擎

1. INNODB存储引擎

   > 1. 特点：
   >
   > > - 事务
   > > - 行级锁
   > > - 外键
   >
   > 2. 存储结构
   >
   >    表空间---段---区---页
   >
   >    页是存储数据的最小存储单元

2. MYISAM存储引擎

   > 1. 特点
   >
   >    > - 不支持事务，不支持外键
   >    > - 表级锁
   >    > - 访问速度较快，适合读请求很高的情形

3. MEMORY存储引擎

   1. 特点：内存存放（存储数据量受内存限制），访问速度快，hash索引，支持表级锁

## 七、SQL优化之其他

1. 插入数据优化
2. 主键优化
3. order by优化
4. group by优化
5. limit优化
6. count优化
7. update优化



## 八、MVCC

## 九、分库分表

- 垂直分库分表

  垂直分库：将数据库中的表按照业务逻辑分到不同的数据库中

  垂直分表：将数据库表中的字段按照一定的相关性拆分到不同的表中（不同的表不一定在同一个服务器中）

- 水平分库分表

  水平分库：将数据库表中数据按照一定的逻辑分散到不同的库中，每个库的数据表结构相同，但是数据不同

  水平分表：将数据库表中数据分到不同的表中，表名不同，数据不同，但是数据结构相同



## 十、索引

1. 索引数据结构

   > - 二叉树：
   >
   >   每个节点下至多有两个节点，如果顺序插入的话容易形成单链表，同时数据量大的情况下，形成的二叉树层级较深，检索效率较低
   >
   > - 红黑树：
   >
   >   自平衡的二叉树，同样也存在数据量大的情况下，树层级较深的问题
   >
   > - B树
   >
   >   所有节点均存储索引和数据，浪费存储空间
   >
   > - B+树
   >
   >   只有叶子节点才有可能存放数据，叶子节点包含所有的索引，非叶子节点中的索引也会出现在叶子节点，叶子节点之间会为护一个单向链表，便于范围查询和排序。MySQL中优化了B+树，提供双向链表
   >
   > - hash表
   >
   >   key-value（行数据的hashcode）键值对存储，随机访问效率高，不支持范围查询。

2. 索引分类

   > - 主键索引
   > - 唯一索引
   > - 常规索引
   > - 全文索引
   > - 聚集索引：数据和索引一起存放，比如主键索引，默认采用主键索引作为聚集索引，如果没有主键，则使用唯一索引作为聚集索引，否则默认生成rowid作为聚集索引，聚集索引只会有一个，叶子节点存放的是具体一行数据
   > - 二级索引：数据和索引分开存放，可能会导致二次回表查询（不是一定会回表，比如覆盖索引），叶子节点存放的是主键值

3.  索引-性能分析

   为了sql性能优化做准备

   > 1. 查看执行频次
   >
   >    看当前数据库各种语句（增删改查）执行频次。
   >
   >    ~~~mysql
   >    show global status like 'Com_______';
   >    ~~~
   >
   >    
   >
   > 2. 慢查询日志：记录了超过指定参数long_query_time（默认10秒）时间的sql，需要在MySQL配置文件my.cnf中修改配置信息，数据会记录在localhost-slow.log中，用户连接信息、执行耗时、主机信息、执行的sql语句
   >
   >    ~~~mysql
   >    show_query_log=1
   >    long_query_time=2
   >    ~~~
   >
   >    
   >
   > 3. show profiles
   >
   >    profile详情可以看到每一条sql的耗时情况，需要打开profile开关，然后通过show profiles指定查看
   >
   >    
   >
   > 4. explain + SQL语句
   >
   >    查看SQL语句的具体执行计划
   >
   >    explain执行计划各部分说明
   >
   >    > - id：
   >    >
   >    >   数值相同的由上到下执行，数值不同的，大的先执行，在多表查询时会有多个id情形
   >    >
   >    > - select_type
   >    >
   >    >   simple、primary、union
   >    >
   >    > - table
   >    >
   >    >   用的是那张表
   >    >
   >    > - patitions
   >    >
   >    > - type
   >    >
   >    >   标识连接类型，性能由好到差为
   >    >
   >    >   NULL：不查询任何表
   >    >
   >    >   const：使用了主键或者唯一索引
   >    >
   >    >   ref：非唯一索引
   >    >
   >    >   range：
   >    >
   >    >   index：
   >    >
   >    >   all：全表扫描
   >    >
   >    > - possible keys：可能用到的索引
   >    >
   >    > - key：实际使用的索引
   >    >
   >    > - key_len：最大可能索引长度，并非实际使用值
   >    >
   >    > - filtered：返回的查询结果占总数的百分比
   >    >
   >    > - extra：一些附加信息，比如order by排序时如果使用了缓存排序则会有file sort和using index

4. 索引——使用原则

   1. 最左前缀法则（针对联合索引）

      查询时需要从索引最左边的列开始，并且不跳过索引字段，如果跳过某个索引字段，则该索引字段后的索引失效。

      该顺序和创建索引的 顺序有关，但是和sql语句中条件的顺序无关

   2. 索引失效情况

      > - 不要在索引列上进行运算操作
      > - 字符串查询时，要加单引号，隐式类型转换导致索引失效
      > - 模糊查询，避免进行头部模糊查询
      > - or连接条件，两侧都要有索引
      > - 数据分布影响。MySQL存储引擎的数据优化器发现如果走索引比全表扫描还慢，就不走索引，比如绝大部分数据都是满足查询条件的

   3. sql提示

      use、force、ignore

   4. 覆盖索引

      尽量避免select *，覆盖索引是指查询的字段都是索引

   5. 前缀索引——varchar、text等文本字符串索引

   6. 单列索引和联合索引

      单列索引更容易导致回表查询，而且浪费存储空间

      联合索引需要注意最左前缀法则

      

      ## 

      

